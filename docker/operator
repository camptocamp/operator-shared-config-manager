#!/usr/bin/env python3

import logging
import os
import sys
import threading
from typing import Any, Dict, TypedDict

import kubernetes  # type: ignore
import yaml

LOG = logging.getLogger(__name__)


class Config(TypedDict):
    name: str
    namespace: str
    labels: Dict[str, str]
    match_labels: Dict[str, str]
    property: str
    configmap_name: str


class Main:
    def __init__(self):

        logging.basicConfig(level=os.environ.get("LOGLEVEL", logging.INFO))

        self.configs: Dict[str, Config] = {}
        self.lock = threading.Lock()

        try:
            kubernetes.config.load_kube_config()
        except:
            kubernetes.config.load_incluster_config()

        self.api = kubernetes.client.CoreV1Api()
        self.custom_api = kubernetes.client.CustomObjectsApi()
        self.watch = kubernetes.watch.Watch()

        watch_sources = threading.Thread(target=self.watch_sources)
        watch_sources.start()
        watch_configs = threading.Thread(target=self.watch_configs)
        watch_configs.start()

    def watch_sources(self) -> None:
        try:
            for event in self.watch.stream(
                self.custom_api.list_cluster_custom_object,
                group="camptocamp.com",
                version="v1",
                plural="sharedconfigsources",
            ):
                metadata = event["object"]["metadata"]

                LOG.debug(
                    "Event %s, Service Name: %s, Namespace: %s",
                    event.get("type"),
                    metadata.get("name"),
                    metadata.get("namespace"),
                )

                labels = metadata.get("labels", {})
                for config in self.configs.values():
                    match = True
                    for label, value in config["match_labels"].items():
                        if label not in labels:
                            match = False
                            break
                        if labels[label] != value:
                            match = False
                            break
                    if match:
                        self.update(config)
            LOG.error("The sources watch exited")
            sys.exit(1)
        except:
            LOG.exception("The error on sources watch")
            sys.exit(1)

    def watch_configs(self) -> None:
        try:
            for event in self.watch.stream(
                self.custom_api.list_cluster_custom_object,
                group="camptocamp.com",
                version="v1",
                plural="sharedconfigconfigs",
            ):
                metadata = event["object"]["metadata"]

                LOG.debug(
                    "Event %s, Service Name: %s, Namespace: %s",
                    event.get("type"),
                    metadata.get("name"),
                    metadata.get("namespace"),
                )

                if event["type"] == "DELETED":
                    self.api.delete_namespaced_config_map(metadata["name"], metadata["namespace"])
                    del self.configs[f"{metadata['namespace']}.{metadata['name']}"]
                    continue

                config_object = self.custom_api.get_namespaced_custom_object(
                    group="camptocamp.com",
                    version="v1",
                    namespace=metadata["namespace"],
                    plural="sharedconfigconfigs",
                    name=metadata["name"],
                )

                self.configs[f"{metadata['namespace']}.{metadata['name']}"] = {
                    "name": metadata["name"],
                    "namespace": metadata["namespace"],
                    "labels": metadata.get("labels", {}),
                    "match_labels": config_object["spec"].get("matchLabels", {}),
                    "property": config_object["spec"].get("property", "sources"),
                    "configmap_name": config_object["spec"].get(
                        "configmapName", "shared_config_manager.yaml"
                    ),
                }
                self.update(self.configs[f"{metadata['namespace']}.{metadata['name']}"])
            LOG.error("The configs watch exited")
            sys.exit(1)
        except:
            LOG.exception("The error on sources watch")
            sys.exit(1)

    def update(self, config: Config) -> None:
        with self.lock:
            selector = ",".join(["=".join(kv) for kv in config["match_labels"].items()])
            LOG.info("Update ConfigMap %s.%s (%s).", config["namespace"], config["name"], selector)

            configmap_content: Dict[str, Any] = {config["property"]: {}}
            custom_object_name_list = self.custom_api.list_cluster_custom_object(
                group="camptocamp.com",
                version="v1",
                plural="sharedconfigsources",
                label_selector=selector,
                watch=False,
            )

            for custom_object in custom_object_name_list["items"]:
                LOG.debug(
                    "Source found: %s.%s",
                    custom_object.get("metadata", {}).get("namespace"),
                    custom_object.get("metadata", {}).get("name"),
                )

                LOG.error(custom_object["spec"])
                name = custom_object["spec"]["name"]
                content = custom_object["spec"]["content"]
                configmap_content[config["property"]][name] = content

            config_map = kubernetes.client.V1ConfigMap(
                metadata=kubernetes.client.V1ObjectMeta(
                    name=config["name"],
                    labels=config["labels"],
                ),
                data={config["configmap_name"]: yaml.dump(configmap_content)},
            )
            try:
                self.api.replace_namespaced_config_map(
                    name=config["name"], namespace=config["namespace"], body=config_map
                )
            except kubernetes.client.exceptions.ApiException:
                self.api.create_namespaced_config_map(namespace=config["namespace"], body=config_map)


if __name__ == "__main__":
    Main()
